{
  "name": "xml-js-converter",
  "version": "1.0.0",
  "description": "Convert XML to a JavaScript object and back, following a specific schema. Define your own rules for how to convert attributes and content",
  "main": "index.js",
  "scripts": {
    "test": "mocha tests"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/bruderstein/xml-js-convert.git"
  },
  "keywords": [
    "xml",
    "json",
    "conversion",
    "convert"
  ],
  "author": {
    "name": "Dave Brotherstone",
    "email": "dave@bruderste.in"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/bruderstein/xml-js-convert/issues"
  },
  "homepage": "https://github.com/bruderstein/xml-js-convert",
  "dependencies": {
    "object-assign": "^3.0.0",
    "sax": "^1.1.1",
    "xmlbuilder": "^2.6.4"
  },
  "devDependencies": {
    "mocha": "^2.2.5",
    "unexpected": "^9.2.1"
  },
  "readme": "# First, a warning\n\nWe use semver, and we're starting at 1.0.0 in order to easily communicate API changes, \nwithout breaking semver. \n\nHowever, it's ***still beta*** and should be used with caution.\n\n\n# xml-js-converter\n\nConvert between an XML string and JavaScript objects (in both directions), following a specific schema. \n\nIf you only need a generic conversion, you will probably find [https://www.npmjs.com/package/xml2js](xml2js) or [https://www.npmjs.com/package/xml2json](xml2json) suits your needs better.\n\nWhat `xml-js-converter` allows you to do, is specify the way in which certain nodes are converted.\nFor instance, say you had the following XML:\n\n```xml\n<person id=\"195\">\n   <firstName>Alan</firstName>\n   <lastName>Turing</lastName>\n</person>\n```\n\nWhat you might want in JavaScript is\n\n```javascript\n{\n    person: {\n        id: '195',\n        firstName: 'Alan',\n        lastName: 'Turing'\n    }\n}\n```\n\nSo the id attribute is a property, but so is the sub-element firstName. Converting back should\nobviously do the same thing, so from the given JavaScript object, you get the same XML back.\n\n## Collections / arrays\n\nSay you had the following XML \n```xml\n<person id=\"195\">\n   <firstName>Alan</firstName>\n   <lastName>Turing</lastName>\n   <skills>\n      <skill id=\"CS101\">Computer theory</skill>\n      <skill id=\"ENIG1\">Code breaking</skill>\n   </skills>\n</person>\n```\n_(The skills list is by no means exhaustive!)_\n\nWhat you can obtain with `xml-js-converter` is the following JavaScript object:\n\n```javascript\n{\n    person: {\n        id: '195',\n        firstName: 'Alan',\n        lastName: 'Turing',\n        skills: [\n            { skill: {\n                id: 'CS101',\n                name: 'Computer theory'\n            },\n            { skill: {\n                id: 'ENIG1',\n                name: 'Code breaking'\n            }\n        ] \n    }\n}\n```\n\nNotice the extra \"skill\" object - ie. an object with a single property \"skill\".  This is so that\nyou can have an array of sub-elements with different tag names.  For instance:\n\n\n```xml\n<person id=\"195\">\n   <firstName>Alan</firstName>\n   <lastName>Turing</lastName>\n   <attributes>\n      <skill id=\"CS101\">Computer theory</skill>\n      <achievement id=\"ENIG1\">Cracked the Enigma code</achievement>\n   </attributes>\n</person>\n```\n\nAnd end up with the JavaScript:\n\n\n```javascript\n{\n    person: {\n        id: '195',\n        firstName: 'Alan',\n        lastName: 'Turing',\n        attributes: [\n            { skill: {\n                id: 'CS101',\n                name: 'Computer theory'\n            },\n            { achievement: {\n                id: 'ENIG1',\n                name: 'Code breaking'\n            }\n        ] \n    }\n}\n\n```\n# Usage\n\n```\nnpm install xml-js-converter\n```\n\n\n```javascript\n\nvar xmlJsConverter = require('xml-js-converter');\n```\n\n## fromXml\n\n``` \nfromXml(xmlAsString, specification, callback) \n```\n\nWhere callback is ``` function (err, value) { ... } ```, err is null unless there was an error,\nand value is the javascript object. ```specification``` is defined in the next section.\n\n```\nxmlJsConverter.fromXml('<demo>text content</demo>', {}, function (err, value) {\n    \n    // value == { demo: { $content: 'text content' } }\n\n});\n```\n\n## toXml\n\n``` \ntoXml(jsObject, specification, callback) \n```\n\nWhere callback is ```function (err, value) { ... } ```, err is null unless there was an error,\nand value is a string with the XML.\n\n\n## Specification\n\nThe specification can be an empty object.  Otherwise each property can define how to handle that tag name.\n\nFor instance:\n\n```javascript\n{\n    test: {}\n}\n```\n\nWould be a (useless, ie. \"non-effect having\") specification for:\n```xml\n\n<test>some content</test>\n```\n\nThis would result in \n\n\n```javascript\n{\n    test: { \n        $content: 'some content'\n    }\n}\n```\n\n`$content` is the default name for the content of a tag.  You can override this in the spec by setting $content.\n\n### $content\n\nSet to a string to name the content property.\ne.g.\n\n\n```javascript\nvar spec = {\n    test: {\n        $content: 'name'\n    }\n};\n\nxmlJsConverter.fromXml('<test>charles babbage</test>', spec, function (err, value) {\n    // value == { \n    //       test: {\n    //              name: 'charles babbage'\n    //       }\n    // };\n});\n```\n\nSet to `false` to suppress the content. Note that attributes of the node will then be skipped,\nas there is nowhere to define them.\n\n\ne.g.\n\n\n```javascript\nvar spec = {\n    test: {\n        $content: false\n    }\n};\n\nxmlJsConverter.fromXml('<test>charles babbage</test>', spec, function (err, value) {\n    // value == { \n    //       test: 'charles babbage'\n    // };\n});\n\n```\n\nTo define `$content` for deeply nested elements, simply define the path to the elements.\n\ne.g.\n\n\n```javascript\nvar spec = {\n    test: {\n        name: {\n            firstName: { $content: false },\n            lastName: { $content: false }\n        }\n    }\n};\n\nxmlJsConverter.fromXml('<test><name>' + \n        '<firstName>charles</firstName>' + \n        '<lastName>babbage</lastName>' + \n        '</name></test>', spec, function (err, value) {\n    // value == { \n    //       test: {\n    //            name: {\n    //                firstName: 'charles',\n    //                lastName: 'babbage'\n    //            }\n    //        }\n    // };\n});\n\n```\n\n\n\n### $arrayElement\n\nSet to true to include the children as an array.  Each child node will be an object with\na single property with the name of the tag, and then follow the conventions of sub-schema.\n\nNote that the array will be the $content property, unless $content is also specified (either \nset as a name or to false to discard the attributes).\n\nFrom the example above:\n\n\n```xml\n<person id=\"195\">\n   <firstName>Alan</firstName>\n   <lastName>Turing</lastName>\n   <attributes>\n      <skill id=\"CS101\">Computer theory</skill>\n      <achievement id=\"ENIG1\">Cracked the Enigma code</achievement>\n   </attributes>\n</person>\n```\n\nTo obtain the following JavaScript:\n\n\n```javascript\n{\n    person: {\n        id: '195',\n        firstName: 'Alan',\n        lastName: 'Turing',\n        attributes: [\n            { skill: {\n                id: 'CS101',\n                name: 'Computer theory'\n            },\n            { achievement: {\n                id: 'ENIG1',\n                name: 'Code breaking'\n            }\n        ] \n    }\n}\n\n```\n\nYou'd use the specification: \n\n```javascript\nvar spec = {\n    person: {\n        firstName: { $content: false },\n        lastName: { $content: false },\n        attributes: {\n            $arrayElement: true,\n            $content: false,\n            achievement: { $content: 'name' },\n            skill: { $content: 'name' }\n        }\n    }\n};\n```\n\nNote how the `$arrayElement` is true, and also `$content` is false for the `attributes` element.\nThis suppresses the $content property for the array.  $content for array elements works exactly\nthe same as normal elements.\n\nThe specs for `achievement` and `skill` will be used for every `achievement` and `skill` element \nin the parent element.  If an unknown element occurs, it will simply use a default specification (`{}`)\n\n\n# Contributing\n\nBugs, pull requests, comments all very welcome.\n\nThe tests are written in [mocha](http://mochajs.org), using the excellent [unexpected](https://github.com/unexpectedjs/unexpected) assertion library.\n\nTo run the tests, just call\n```\nnpm test\n```\n\n# Versioning\n\nWe follow [semver](http://semver.org). We have started at version 1.0, not symbolise \"production ready\",\nbut to effectively communicate changes.\n\n\n# Roadmap\n\nThings we'd like soon:\n\n* Support for numeric types\n* Support to automatically case-switch (e.g. PascalCase in XML and camelCase in JS)\n\nThings we'd like eventually:\n\n* Support for naming nodes differently in JS and XML \n* Support for dropping the wrapper on arrayElements\n  e.g. from \n  \n  ```xml\n  <people>\n    <person name=\"monica\" />\n    <person name=\"steve\" />\n  </people>\n  ``` \n\nTo be transformed to\n\n```javascript\n  { people: [ { name: 'monica' }, { name: 'steve' } ] }\n```\n\n\n* Support for using an attribute as the \"content\"\n  e.g. from\n\n```xml\n   <director>\n      <person name=\"tim cook\" />\n   </director>\n```\n\n   To be transformed to \n```javascript\n{\n    director: {\n        person: 'tim cook'\n    }\n}\n```\nThis would also enable the `people` array in the previous example to be transformed to a simple array of strings.\n\n\n",
  "readmeFilename": "README.md",
  "_id": "xml-js-converter@1.0.0",
  "_from": "xml-js-converter@"
}
